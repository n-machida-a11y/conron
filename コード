/**
 * Webアプリのメインエントリーポイント
 */
function doGet(e) {
  return HtmlService.createTemplateFromFile("index")
    .evaluate()
    .setTitle("ナカノ企画書 2025 Autumn&Winter Collection")
    .addMetaTag("viewport", "width=device-width, initial-scale=1.0");
}

/**
 * 画像URLマップを作成してキャッシュする
 * シート名: 絵型 (旧: 写真)
 */
function getImageUrlMap() {
  const cache = CacheService.getScriptCache();
  // ★キャッシュキーを再変更し、確実にマップを再作成させます
  const CACHE_KEY = "IMAGE_URL_MAP_V9_DEBUG_LOG"; // デバッグ用にキーを更新
  const CACHE_TIMEOUT_SECONDS = 3600; 

  let cachedMap = cache.get(CACHE_KEY);
  if (cachedMap) {
    Logger.log("画像URLマップ: キャッシュを使用しました。");
    return JSON.parse(cachedMap);
  }

  Logger.log("画像URLマップのキャッシュを再構築します...");
  const imageUrlMap = {};
  
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const photoSheet = ss.getSheetByName("絵型");
    if (!photoSheet) {
      Logger.log("シート「絵型」が見つかりませんでした。");
      return {};
    }
    
    const photoLastRow = photoSheet.getLastRow();
    if (photoLastRow < 2) return {};
    
    const photoValues = photoSheet.getRange(2, 1, photoLastRow - 1, 4).getValues(); 
    
    let imageFolderName = null;
    for (const row of photoValues) {
      const path = row[3]; 
      if (path && typeof path === 'string' && path.includes('/')) {
        imageFolderName = path.split('/')[0];
        break;
      }
    }

    if (!imageFolderName) {
      Logger.log("画像フォルダ名が特定できませんでした。");
      return {};
    }
    
    Logger.log(`特定された画像フォルダ名: ${imageFolderName}`);
    
    // フォルダ特定のロジックは変更なし
    let imageFolder = null;
    try {
      const ssFile = DriveApp.getFileById(ss.getId());
      const parents = ssFile.getParents();
      while (parents.hasNext()) {
        const parent = parents.next();
        const folders = parent.getFoldersByName(imageFolderName);
        if (folders.hasNext()) {
          imageFolder = folders.next();
          Logger.log(`成功: Spreadsheetと同じ階層に画像フォルダ "${imageFolderName}" を発見しました。`);
          break;
        }
      }
    } catch (e) {
      Logger.log("親フォルダ検索エラー: " + e.message);
    }

    if (!imageFolder) {
      Logger.log("親階層に見つからないため、ドライブ全体から検索します。");
      const folders = DriveApp.getFoldersByName(imageFolderName);
      if (folders.hasNext()) {
        imageFolder = folders.next();
        Logger.log(`成功: ドライブ全体から画像フォルダ "${imageFolderName}" を発見しました。`);
      }
    }

    if (!imageFolder) {
       Logger.log(`失敗: 画像フォルダ "${imageFolderName}" が見つかりません。`);
       return {};
    }
    
    const files = imageFolder.getFiles();
    
    while (files.hasNext()) {
      const file = files.next();
      const fileName = file.getName();
      
      // ★修正ポイント: より柔軟なキー抽出ロジックを導入
      let idPart = null;

      // 1. ドット区切りがある場合 (AppSheet形式: XXXXXX.png.YYY.jpg)
      const parts = fileName.split('.');
      if (parts.length > 1) {
          idPart = parts[0].trim();
      }
      
      // 2. 拡張子だけがある場合 (直接アップロード形式: XXXXXX.png)
      // ドットが1つだけ、かつID部分がまだ未設定の場合に、拡張子を除いたファイル名全体をキーにする
      if (!idPart && parts.length <= 2) {
          idPart = parts[0].trim();
      }
      
      if (idPart) {
        // キーに拡張子が含まれないように再度処理
        const cleanIdPart = idPart.split('.')[0].trim();
        if (cleanIdPart) {
            imageUrlMap[cleanIdPart] = file.getId();
            Logger.log(`マップ登録: ファイル名 "${fileName}" -> キー "${cleanIdPart}"`); // ★デバッグログ追加
        }
      }
    }

    cache.put(CACHE_KEY, JSON.stringify(imageUrlMap), CACHE_TIMEOUT_SECONDS);
    return imageUrlMap;

  } catch (err) {
    Logger.log("getImageUrlMap Error: " + err.message);
    return {};
  }
}

/**
 * 商品データを取得する
 */
function getProductData() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    
    // シート名と取得
    const kikakuSheet = ss.getSheetByName("企画管理");
    const colorSheet = ss.getSheetByName("カラー");
    const sizeSheet = ss.getSheetByName("サイズ");
    const photoSheet = ss.getSheetByName("絵型");
    // const fabricSheet = ss.getSheetByName("生地"); // 生地シートは不要

    // 必須シートの存在チェック
    if (!kikakuSheet) {
      throw new Error("スプレッドシート内に「企画管理」シートが見つかりませんでした。");
    }
    
    // データ最終行の取得
    const kikakuLastRow = kikakuSheet.getLastRow();
    // 必須ではないシートは、存在しない場合は空の配列で代用できるように調整
    const colorLastRow = colorSheet ? colorSheet.getLastRow() : 1;
    const sizeLastRow = sizeSheet ? sizeSheet.getLastRow() : 1;
    const photoLastRow = photoSheet ? photoSheet.getLastRow() : 1;

    // 企画管理の列数を15列に更新
    const KIKAKU_MAX_COL = 15; 
    const kikakuValues = (kikakuLastRow > 1) ? kikakuSheet.getRange(2, 1, kikakuLastRow - 1, KIKAKU_MAX_COL).getValues() : [];
    
    // データ取得（シートが存在しない場合は空の配列を返す）
    const colorValues = (colorLastRow > 1 && colorSheet) ? colorSheet.getRange(2, 1, colorLastRow - 1, 3).getValues() : [];
    const sizeValues = (sizeLastRow > 1 && sizeSheet) ? sizeSheet.getRange(2, 1, sizeLastRow - 1, 2).getValues() : [];
    const photoValues = (photoLastRow > 1 && photoSheet) ? photoSheet.getRange(2, 1, photoLastRow - 1, 4).getValues() : [];

    const imageUrlMap = getImageUrlMap();

    // 新しい企画管理の列定義に基づくマッピング (0-indexed)
    // [管理ID(0), 仮品番(1), 定番/外注(2), 品番(3), 品名(4), シーズン(5), ブランド(6), カテゴリー(7), サイズ(8),
    // 上代(9), 下代(10), 生地番号(11), 生地名(12), 進捗(13), 仕様書担当者(14)]
    const KIKAKU_MAP = {
      kanriId: 0,       // 管理ID
      shinchoku: 13,    // 進捗 (13)
      hinban: 3,        // 品番 (商品IDとして使用)
      hinmei: 4,        // 品名
      season: 5,        // シーズン
      category: 7,      // カテゴリー
      jodai: 9,         // 上代 (9)
      gedai: 10,        // 下代 (10)
      fabric_number: 11, // 生地番号 (11)
      material_name: 12  // 生地名 (12)
    };
    
    // [カラー番号, 管理ID, カラー名]
    const COLOR_MAP = { 
      kanriId: 1,       // 管理ID (B列)
      colorName: 2      // カラー名 (C列)
    }; 
    
    // [管理ID, サイズ名] (変更なしと仮定)
    const SIZE_MAP = { kanriId: 0, size: 1 }; 

    // [絵型ID, 管理ID, タイトル, 写真(Path)]
    const PHOTO_MAP = { 
      kanriId: 1,       // 管理ID (B列)
      shashinId: 0      // 絵型ID (A列, 画像ファイルIDのキーとして使用)
    };
    
    // FABRIC_MAPは不要

    // --- マップ作成 (カラー) ---
    const colorsMap = colorValues.reduce((acc, row) => {
      const id = row[COLOR_MAP.kanriId];
      if (id) {
        if (!acc[id]) acc[id] = [];
        acc[id].push(row[COLOR_MAP.colorName]);
      }
      return acc;
    }, {});

    // --- マップ作成 (サイズ) --- (ロジック変更なし)
    const sizesMap = sizeValues.reduce((acc, row) => {
      const id = row[SIZE_MAP.kanriId];
      if (id) {
        if (!acc[id]) acc[id] = [];
        acc[id].push(row[SIZE_MAP.size]);
      }
      return acc;
    }, {});

    // --- マップ作成 (絵型/写真) ---
    const photosMap = photoValues.reduce((acc, row) => {
      const id = row[PHOTO_MAP.kanriId];           // B列: 管理ID
      const shashinId = row[PHOTO_MAP.shashinId];   // A列: 絵型ID (ファイルID部分)
      
      const cleanShashinId = shashinId ? String(shashinId).trim() : "";
      
      if (id && cleanShashinId) {
        if (!acc[id]) acc[id] = [];
        if (!acc[id].includes(cleanShashinId)) {
            acc[id].push(cleanShashinId);
        }
      }
      return acc;
    }, {});

    // --- データ組み立て ---
    const productData = [];
    
    const cleanPrice = (v) => {
      if (typeof v === 'number') return v;
      if (typeof v === 'string') return parseFloat(v.replace(/[¥,]/g, '')) || 0;
      return 0;
    };
    
    for (const row of kikakuValues) {
      const kanriId = row[KIKAKU_MAP.kanriId];
      if (!kanriId) continue;

      // const fabricInfo = fabricsMap[kanriId] || {}; // 削除
      
      const shashinIds = photosMap[kanriId] || [];
      const imageUrls = [];
      
      if (shashinIds.length > 0) {
        shashinIds.forEach(sid => {
            const fileId = imageUrlMap[sid]; // sidはcleanShashinId
            if (fileId) {
                // ★修正箇所: DriveApp.getFileById(fileId).getDownloadUrl() も使用可能だが、
                // uc?id= が最も一般的。ただし、組織内アクセス制限のため、公開設定を回避する ?export=download を追加
                // https://drive.google.com/uc?export=download&id={ファイルID} を使用する
                imageUrls.push(`https://drive.google.com/uc?export=download&id=${fileId}`);
            } else {
                Logger.log(`注意: 管理ID ${kanriId} (絵型ID ${sid}) のファイルIDがマップに見つかりません。`); // ★デバッグログ追加
            }
        });
      }
      
      // 画像がない場合のプレースホルダー
      if (imageUrls.length === 0) {
        imageUrls.push("https://placehold.co/400x400/f3f4f6/9ca3af?text=No+Image");
      }

      const product = {
        id: row[KIKAKU_MAP.hinban] || kanriId,
        kanriId: kanriId, 
        category: row[KIKAKU_MAP.category] || "N/A",
        season: row[KIKAKU_MAP.season] || "N/A",
        name: row[KIKAKU_MAP.hinmei] || "（品名未設定）",
        status: row[KIKAKU_MAP.shinchoku] || "N/A",
        colors: colorsMap[kanriId] || [],
        
        // 上代・下代を取得
        price_retail: cleanPrice(row[KIKAKU_MAP.jodai]),
        price_wholesale: cleanPrice(row[KIKAKU_MAP.gedai]),
        
        // 生地情報を企画管理シートから直接取得 (インデックス 11, 12)
        material_name: row[KIKAKU_MAP.material_name] || "N/A",
        // composition (混率) はN/Aに固定
        composition: "N/A", 
        sizes: sizesMap[kanriId] || [],
        fabric_number: row[KIKAKU_MAP.fabric_number] || "N/A", // 生地番号(11)
        
        images: imageUrls, 
        imageUrl: imageUrls[0] 
      };
      
      productData.push(product);
    }

    return productData;

  } catch (err) {
    // throw Errorの場合も、ここでフロントエンドに返す
    Logger.log("Error in getProductData: " + err);
    return { error: `データの読み込み中にエラーが発生しました: ${err.message}` };
  }
}
